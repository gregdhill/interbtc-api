import { ApiPromise } from "@polkadot/api";
import { SubmittableExtrinsic } from "@polkadot/api/submittable/types";
import { Hash, H256 } from "@polkadot/types/interfaces";
import { EventRecord } from "@polkadot/types/interfaces";
import { Option } from "@polkadot/types";
import { Network } from "bitcoinjs-lib";
import Big from "big.js";
import { Bitcoin, BitcoinAmount, ExchangeRate, MonetaryAmount } from "@interlay/monetary-js";
import { ApiTypes, AugmentedEvent } from "@polkadot/api/types";
import type { AnyTuple } from "@polkadot/types/types";
import { ISubmittableResult } from "@polkadot/types/types";
import {
    BitcoinAddress,
    InterbtcPrimitivesVaultId,
    InterbtcPrimitivesRedeemRedeemRequest,
} from "@polkadot/types/lookup";

import { VaultsAPI } from "./vaults";
import {
    decodeBtcAddress,
    decodeFixedPointType,
    getTxProof,
    storageKeyToNthInner,
    ensureHashEncoded,
    parseRedeemRequest,
    newMonetaryAmount,
    newVaultCurrencyPair,
} from "../utils";
import { allocateAmountsToVaults, getRequestIdsFromEvents } from "../utils/issueRedeem";
import { ElectrsAPI } from "../external";
import { TransactionAPI } from "./transaction";
import { OracleAPI } from "./oracle";
import { CollateralCurrencyExt, Redeem, WrappedCurrency } from "../types";
import { AssetRegistryAPI } from "../parachain/asset-registry";
import { SystemAPI } from "./system";

/**
 * @category BTC Bridge
 */
export interface RedeemAPI {
    /**
     * @returns An array containing the redeem requests
     */
    list(): Promise<Redeem[]>;

    /**
     * Build a request redeem extrinsic (transaction) without sending it.
     *
     * @param vaultId ID of the vault to redeem with.
     * @param amount Wrapped token amount to redeem
     * @param btcAddress Bitcoin transaction ID
     * @returns A request redeem submittable extrinsic.
     */
    buildRequestRedeemExtrinsic(
        vaultId: InterbtcPrimitivesVaultId,
        amount: MonetaryAmount<WrappedCurrency>,
        btcAddress: string
    ): SubmittableExtrinsic<"promise", ISubmittableResult>;
    /**
     * Send a redeem request transaction
     * @param amount Wrapped token amount to redeem
     * @param btcAddressEnc Bitcoin address where the redeemed BTC should be sent
     * @param vaultId (optional) ID of the vault to redeem with.
     * @param atomic (optional) Whether the request should be handled atomically or not. Only makes a difference
     * if more than one vault is needed to fulfil it. Defaults to false.
     * @param retries (optional) Number of times to retry redeeming, if some of the requests fail. Defaults to 0.
     * @param availableVaults (optional) A list of all vaults usable for redeem. If not provided, will fetch from the parachain.
     * @returns An array of type {redeemId, redeemRequest} if the requests succeeded. The function throws an error otherwise.
     */
    request(
        amount: MonetaryAmount<WrappedCurrency>,
        btcAddressEnc: string,
        vaultId?: InterbtcPrimitivesVaultId,
        atomic?: boolean,
        retries?: number,
        availableVaults?: Map<InterbtcPrimitivesVaultId, MonetaryAmount<WrappedCurrency>>
    ): Promise<Redeem[]>;

    /**
     * Send a batch of aggregated redeem transactions (to one or more vaults)
     * @param amountsPerVault A mapping of vaults to redeem from, and wrapped token amounts to redeem using each vault
     * @param btcAddressEnc Bitcoin address where the redeemed BTC should be sent
     * @param atomic Whether the issue request should be handled atomically or not. Only makes a difference if more than
     * one vault is needed to fulfil it.
     * @returns An array of type {redeemId, vault} if the requests succeeded.
     * @throws Rejects the promise if none of the requests succeeded (or if at least one failed, when atomic=true).
     */
    requestAdvanced(
        amountsPerVault: Map<InterbtcPrimitivesVaultId, MonetaryAmount<WrappedCurrency>>,
        btcAddressEnc: string,
        atomic: boolean
    ): Promise<Redeem[]>;

    /**
     * Build a redeem execution extrinsic (transaction) without sending it.
     *
     * @param redeemId The ID returned by the issue request transaction
     * @param btcTxId Bitcoin transaction ID
     * @returns An execute redeem submittable extrinsic.
     */
    buildExecuteRedeemExtrinsic(
        redeemId: string,
        btcTxId: string
    ): Promise<SubmittableExtrinsic<"promise", ISubmittableResult>>;

    /**
     * Send a redeem execution transaction
     * @remarks If `txId` is not set, the `merkleProof` and `rawTx` must both be set.
     *
     * @param redeemId The ID generated by the redeem request transaction
     * @param btcTxId Bitcoin transaction ID
     */
    execute(requestId: string, btcTxId: string): Promise<void>;

    /**
     * Build a cancel redeem extrinsic (transaction) without sending it.
     *
     * @param redeemId The ID returned by the redeem request transaction
     * @param reimburse In case of redeem failure:
     *  - `false` = retry redeeming, with a different Vault
     *  - `true` = accept reimbursement in wrapped token
     * @returns A cancel redeem submittable extrinsic.
     */
    buildCancelRedeemExtrinsic(
        redeemId: string,
        reimburse: boolean
    ): SubmittableExtrinsic<"promise", ISubmittableResult>;

    /**
     * Send a redeem cancellation transaction. After the redeem period has elapsed,
     * the redeemal request can be cancelled. As a result, the griefing collateral
     * of the vault will be slashed and sent to the redeemer
     * @param redeemId The ID returned by the redeem request transaction
     * @param reimburse (Optional) In case of redeem failure:
     *  - (Default) `false` = retry redeeming, with a different Vault
     *  - `true` = accept reimbursement in wrapped token
     */
    cancel(redeemId: string, reimburse?: boolean): Promise<void>;
    /**
     * @remarks Testnet utility function
     * @param blocks The time difference in number of blocks between a redeem request
     * is created and required completion time by a vault.
     * The redeem period has an upper limit to ensure the user gets their BTC in time
     * and to potentially punish a vault for inactivity or stealing BTC.
     */
    setRedeemPeriod(blocks: number): Promise<void>;
    /**
     *
     * @returns The time difference in number of blocks between a redeem request
     * is created and required completion time by a vault.
     * The redeem period has an upper limit to ensure the user gets their BTC in time
     * and to potentially punish a vault for inactivity or stealing BTC.
     */
    getRedeemPeriod(): Promise<number>;
    /**
     * @param redeemId The ID of the redeem request to fetch
     * @returns A redeem request object
     */
    getRequestById(redeemId: H256 | string): Promise<Redeem>;
    getRequestsByIds(redeemIds: (H256 | string)[]): Promise<Redeem[]>;
    /**
     * @returns The minimum amount of wrapped tokens that is accepted for redeem requests; any lower values would
     * risk the bitcoin client to reject the payment
     */
    getDustValue(): Promise<MonetaryAmount<WrappedCurrency>>;
    /**
     * @returns The fee charged for redeeming. For instance, "0.005" stands for 0.5%
     */
    getFeeRate(): Promise<Big>;
    /**
     * @param amount The amount of wrapped tokens for which to compute the redeem fees
     * @returns The fees
     */
    getFeesToPay(amount: MonetaryAmount<WrappedCurrency>): Promise<MonetaryAmount<WrappedCurrency>>;
    /**
     * @returns If users execute a redeem with a Vault flagged for premium redeem,
     * they can earn a premium, slashed from the Vault's collateral.
     * This value is a percentage of the redeemed amount.
     */
    getPremiumRedeemFeeRate(): Promise<Big>;

    /**
     * Build liquidation redeem extrinsic (without sending it) to burn wrapped tokens for a premium
     * @param amount The amount of wrapped tokens to burn
     * @param collateralCurrency Liquidated collateral currency to use when burning wrapped tokens
     * @returns A liquidation redeem submittable extrinsic.
     */
    buildLiquidationRedeemExtrinsic(
        amount: MonetaryAmount<WrappedCurrency>,
        collateralCurrency: CollateralCurrencyExt
    ): SubmittableExtrinsic<"promise", ISubmittableResult>;

    /**
     * Burn wrapped tokens for a premium
     * @param amount The amount of wrapped tokens to burn
     * @param collateralCurrency Liquidated collateral currency to use when burning wrapped tokens
     */
    burn(amount: MonetaryAmount<WrappedCurrency>, collateralCurrency: CollateralCurrencyExt): Promise<void>;
    /**
     * @param collateralCurrency Liquidated collateral currency to use when burning wrapped tokens
     * @returns The maximum amount of tokens that can be burned through a liquidation redeem
     */
    getMaxBurnableTokens(collateralCurrency: CollateralCurrencyExt): Promise<MonetaryAmount<WrappedCurrency>>;
    /**
     * @param collateralCurrency Currency whose exchange rate with BTC to fetch
     * @returns The exchange rate (collateral currency to wrapped token currency)
     * used when burning tokens
     */
    getBurnExchangeRate(
        collateralCurrency: CollateralCurrencyExt
    ): Promise<ExchangeRate<Bitcoin, typeof collateralCurrency>>;
    /**
     * @returns The current inclusion fee based on the expected number of bytes
     * in the transaction, and the inclusion fee rate reported by the oracle
     */
    getCurrentInclusionFee(): Promise<MonetaryAmount<WrappedCurrency>>;
}

export class DefaultRedeemAPI implements RedeemAPI {
    constructor(
        private api: ApiPromise,
        private btcNetwork: Network,
        private electrsAPI: ElectrsAPI,
        private wrappedCurrency: WrappedCurrency,
        private vaultsAPI: VaultsAPI,
        private oracleAPI: OracleAPI,
        private transactionAPI: TransactionAPI,
        private assetRgistryAPI: AssetRegistryAPI,
        private systemAPI: SystemAPI
    ) {}

    private getRedeemIdsFromEvents(events: EventRecord[], event: AugmentedEvent<ApiTypes, AnyTuple>): Hash[] {
        return getRequestIdsFromEvents(events, event, this.api);
    }

    async request(
        amount: MonetaryAmount<WrappedCurrency>,
        btcAddressEnc: string,
        vaultId?: InterbtcPrimitivesVaultId,
        atomic: boolean = true,
        retries: number = 0,
        cachedVaults?: Map<InterbtcPrimitivesVaultId, MonetaryAmount<WrappedCurrency>>
    ): Promise<Redeem[]> {
        try {
            if (vaultId) {
                // If a vault account id is defined, request to issue with that vault only.
                // Initialize the `amountsPerVault` map with a single entry, the (vaultId, amount) pair
                const amountsPerVault = new Map<InterbtcPrimitivesVaultId, MonetaryAmount<WrappedCurrency>>([
                    [vaultId, amount],
                ]);
                return await this.requestAdvanced(amountsPerVault, btcAddressEnc, atomic);
            }
            const availableVaults = cachedVaults || (await this.vaultsAPI.getVaultsWithRedeemableTokens());
            const amountsPerVault = allocateAmountsToVaults(availableVaults, amount);
            const result = await this.requestAdvanced(amountsPerVault, btcAddressEnc, atomic);
            const successfulSum = result.reduce(
                (sum, req) => sum.add(req.amountBTC),
                newMonetaryAmount(0, this.wrappedCurrency)
            );
            const remainder = amount.sub(successfulSum);
            if (remainder.isZero() || retries === 0) return result;
            else {
                return (
                    await this.request(remainder, btcAddressEnc, vaultId, atomic, retries - 1, availableVaults)
                ).concat(result);
            }
        } catch (e) {
            return Promise.reject(e);
        }
    }

    buildRequestRedeemExtrinsic(
        vaultId: InterbtcPrimitivesVaultId,
        amount: MonetaryAmount<WrappedCurrency>,
        btcAddressEnc: string
    ): SubmittableExtrinsic<"promise", ISubmittableResult> {
        const btcAddress = this.api.createType<BitcoinAddress>(
            "BitcoinAddress",
            decodeBtcAddress(btcAddressEnc, this.btcNetwork)
        );
        const amountInAtomicUnits = amount.toString(true);
        return this.api.tx.redeem.requestRedeem(amountInAtomicUnits, btcAddress, vaultId);
    }

    async requestAdvanced(
        amountsPerVault: Map<InterbtcPrimitivesVaultId, MonetaryAmount<WrappedCurrency>>,
        btcAddressEnc: string,
        atomic: boolean
    ): Promise<Redeem[]> {
        const txes = Array.from(amountsPerVault).map(([vaultId, amount]) =>
            this.buildRequestRedeemExtrinsic(vaultId, amount, btcAddressEnc)
        );
        const batch = this.transactionAPI.buildBatchExtrinsic(txes, atomic);
        try {
            // When requesting a redeem, wait for the finalized event because we cannot revert BTC transactions.
            // For more details see: https://github.com/interlay/interbtc-api/pull/373#issuecomment-1058949000
            const result = await this.transactionAPI.sendLogged(batch, this.api.events.issue.RequestRedeem);
            const ids = this.getRedeemIdsFromEvents(result.events, this.api.events.redeem.RequestRedeem);
            const redeemRequests = await this.getRequestsByIds(ids);
            return redeemRequests;
        } catch (e) {
            return Promise.reject(e);
        }
    }

    async buildExecuteRedeemExtrinsic(
        redeemId: string,
        btcTxId: string
    ): Promise<SubmittableExtrinsic<"promise", ISubmittableResult>> {
        const parsedRequestId = ensureHashEncoded(this.api, redeemId);
        const txInclusionDetails = await getTxProof(this.electrsAPI, btcTxId);
        return this.api.tx.redeem.executeRedeem(
            parsedRequestId,
            txInclusionDetails.merkleProof,
            txInclusionDetails.rawTx
        );
    }

    async execute(requestId: string, btcTxId: string): Promise<void> {
        const tx = await this.buildExecuteRedeemExtrinsic(requestId, btcTxId);
        await this.transactionAPI.sendLogged(tx, this.api.events.redeem.ExecuteRedeem, true);
    }

    buildCancelRedeemExtrinsic(
        redeemId: string,
        reimburse: boolean
    ): SubmittableExtrinsic<"promise", ISubmittableResult> {
        const parsedRequestId = ensureHashEncoded(this.api, redeemId);
        return this.api.tx.redeem.cancelRedeem(parsedRequestId, reimburse);
    }

    async cancel(requestId: string, reimburse = false): Promise<void> {
        const cancelRedeemTx = this.buildCancelRedeemExtrinsic(requestId, reimburse);
        await this.transactionAPI.sendLogged(cancelRedeemTx, this.api.events.redeem.CancelRedeem, true);
    }

    buildLiquidationRedeemExtrinsic(
        amount: MonetaryAmount<WrappedCurrency>,
        collateralCurrency: CollateralCurrencyExt
    ): SubmittableExtrinsic<"promise", ISubmittableResult> {
        const vaultCurrencyPair = newVaultCurrencyPair(this.api, collateralCurrency, this.wrappedCurrency);
        const amountAtomicUnit = this.api.createType("Balance", amount.toString(true));
        return this.api.tx.redeem.liquidationRedeem(vaultCurrencyPair, amountAtomicUnit);
    }

    async burn(amount: MonetaryAmount<WrappedCurrency>, collateralCurrency: CollateralCurrencyExt): Promise<void> {
        const burnRedeemTx = this.buildLiquidationRedeemExtrinsic(amount, collateralCurrency);
        await this.transactionAPI.sendLogged(burnRedeemTx, this.api.events.redeem.LiquidationRedeem, true);
    }

    async setRedeemPeriod(blocks: number): Promise<void> {
        const period = this.api.createType("BlockNumber", blocks);
        const tx = this.api.tx.sudo.sudo(this.api.tx.redeem.setRedeemPeriod(period));
        await this.transactionAPI.sendLogged(tx, undefined, true);
    }

    async getRedeemPeriod(): Promise<number> {
        const blockNumber = await this.api.query.redeem.redeemPeriod();
        return blockNumber.toNumber();
    }

    async getMaxBurnableTokens(collateralCurrency: CollateralCurrencyExt): Promise<MonetaryAmount<WrappedCurrency>> {
        const liquidationVault = await this.vaultsAPI.getLiquidationVault(collateralCurrency);
        // This should never be below 0, but still...
        const burnableTokens = liquidationVault.issuedTokens.sub(liquidationVault.toBeRedeemedTokens);
        if (burnableTokens.lte(BitcoinAmount.zero())) {
            return BitcoinAmount.zero();
        } else {
            return burnableTokens;
        }
    }

    async getBurnExchangeRate(
        collateralCurrency: CollateralCurrencyExt
    ): Promise<ExchangeRate<Bitcoin, typeof collateralCurrency>> {
        const liquidationVault = await this.vaultsAPI.getLiquidationVault(collateralCurrency);
        const burnableAmount = liquidationVault.issuedTokens
            .add(liquidationVault.toBeIssuedTokens)
            .sub(liquidationVault.toBeRedeemedTokens);
        if (burnableAmount.isZero()) {
            return Promise.reject(new Error("There are no burnable tokens. The burn exchange rate is undefined"));
        }
        const collateralAmount = liquidationVault.collateral;
        const exchangeRate = collateralAmount.toBig().div(burnableAmount.toBig());
        return new ExchangeRate<Bitcoin, typeof collateralCurrency>(Bitcoin, collateralCurrency, exchangeRate);
    }

    async getCurrentInclusionFee(): Promise<MonetaryAmount<WrappedCurrency>> {
        const [size, satoshiFees] = await Promise.all([
            this.api.query.redeem.redeemTransactionSize(),
            this.oracleAPI.getBitcoinFees(),
        ]);
        const btcFees = newMonetaryAmount(satoshiFees, this.wrappedCurrency);
        return btcFees.mul(size.toString());
    }

    async list(): Promise<Redeem[]> {
        const head = await this.api.rpc.chain.getFinalizedHead();

        const [redeemRequests, redeemPeriod, activeBlockNumber] = await Promise.all([
            this.api.query.redeem.redeemRequests.entriesAt(head),
            this.getRedeemPeriod(),
            this.systemAPI.getCurrentActiveBlockNumber(head),
        ]);
        return await Promise.all(
            redeemRequests
                .filter(([_, req]) => req.isSome.valueOf())
                // Can be unwrapped because the filter removes `None` values
                .map(([id, req]) => {
                    return parseRedeemRequest(
                        this.vaultsAPI,
                        this.assetRgistryAPI,
                        req.unwrap(),
                        this.btcNetwork,
                        storageKeyToNthInner(id),
                        redeemPeriod,
                        activeBlockNumber
                    );
                })
        );
    }

    async getFeesToPay(amount: MonetaryAmount<WrappedCurrency>): Promise<MonetaryAmount<WrappedCurrency>> {
        const feePercentage = await this.getFeeRate();
        return amount.mul(feePercentage);
    }

    async getFeeRate(): Promise<Big> {
        const redeemFee = await this.api.query.fee.redeemFee();
        return decodeFixedPointType(redeemFee);
    }

    async getDustValue(): Promise<MonetaryAmount<WrappedCurrency>> {
        const dustValueSat = await this.api.query.redeem.redeemBtcDustValue();
        return newMonetaryAmount(dustValueSat.toString(), this.wrappedCurrency);
    }

    async getPremiumRedeemFeeRate(): Promise<Big> {
        const premiumRedeemFee = await this.api.query.fee.premiumRedeemFee();
        return decodeFixedPointType(premiumRedeemFee);
    }

    async getRequestById(redeemId: H256 | string): Promise<Redeem> {
        const id = ensureHashEncoded(this.api, redeemId);
        return (await this.getRequestsByIds([id]))[0];
    }

    async getRequestsByIds(redeemIds: (H256 | string)[]): Promise<Redeem[]> {
        const redeemRequestData = await Promise.all(
            redeemIds.map(
                async (redeemId): Promise<[Option<InterbtcPrimitivesRedeemRedeemRequest>, H256 | string]> =>
                    new Promise((resolve, reject) => {
                        this.api.query.redeem
                            .redeemRequests(ensureHashEncoded(this.api, redeemId))
                            .then((request) => resolve([request, redeemId]))
                            .catch(reject);
                    })
            )
        );
        const [redeemPeriod, activeBlockCount] = await Promise.all([
            this.getRedeemPeriod(),
            this.systemAPI.getCurrentActiveBlockNumber(),
        ]);

        return Promise.all(
            redeemRequestData
                .filter(([option, _]) => option.isSome)
                .map(([redeemRequest, redeemId]) =>
                    parseRedeemRequest(
                        this.vaultsAPI,
                        this.assetRgistryAPI,
                        redeemRequest.unwrap(),
                        this.btcNetwork,
                        redeemId,
                        redeemPeriod,
                        activeBlockCount
                    )
                )
        );
    }
}
